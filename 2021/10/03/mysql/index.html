<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="mysql, 半亩方塘">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>mysql | 半亩方塘</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">半亩方塘</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">半亩方塘</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/2.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">mysql</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-10-03
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[TOC]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//要找到经纬度差距与米的差距的关系，就是相隔1米，那么维度应该相差多少，精度应该相差多少</span><br><span class="line">AND POWER(ABS((G1.LAT / 0.00000899 - #&#123;lat&#125; / 0.00000899)), 2) + POWER(ABS((G1.LON / 0.00001141 - #&#123;lon&#125; / 0.00001141)), 2) &lt;![CDATA[&lt;=]]&gt; POWER(#&#123;radius&#125;, 2)</span><br><span class="line">    AND VEHICLENO LIKE CONCAT(#&#123;chepaihao&#125;, &#x27;%&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p>mysql是一种关系型数据库，默认端口号是3306.</p>
<p>MyISAM是Mysql5.5以前的数据库默认引擎，但是其不支持事务和行锁，最大缺点在于崩溃后无法恢复。</p>
<p>Mysql与MyISAM的对比：</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>mysql</th>
<th>myisam</th>
</tr>
</thead>
<tbody><tr>
<td>是否支持行锁</td>
<td>支持</td>
<td>不支持，只支持表级锁</td>
</tr>
<tr>
<td>是否支持事务</td>
<td>支持</td>
<td>不支持，但执行速度快（只保证原子性）</td>
</tr>
<tr>
<td>是否支持外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>是否支持MVCC</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>如果不考虑并发能力，不需要事务支持，则可以考虑MyIsam。</p>
<p>MyIsam适合读密集型。Innodb适合写密集型。</p>
<h2 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1 什么是事务"></a>1 什么是事务</h2><ul>
<li>事务是需要保证原子性、隔离性、一致性、和持久性的一组数据库操作。。</li>
</ul>
<p>以一个例子来说就是转账。我要给你1000元，在计算机中设计两个关键的步骤</p>
<ol>
<li>将我的账户减少1000</li>
<li>将你的账户增加1000</li>
</ol>
<p>事务就是要保证这一组操作要么都成功，要么都失败。</p>
<h3 id="1-1-事务的状态"><a href="#1-1-事务的状态" class="headerlink" title="1.1 事务的状态"></a>1.1 事务的状态</h3><p>①活动态：事务正在执行</p>
<p>②部分提交的：事务最后操作执行完成，但是还没提交到磁盘中。</p>
<p>③失败的：在活动态或者部分提交时遇到问题</p>
<p>④中止的：失败状态回滚完毕之后就处于中止态</p>
<p>⑤提交的：部分提交的状态下数据同步到磁盘后</p>
<h2 id="2-事务的特性（ACID）"><a href="#2-事务的特性（ACID）" class="headerlink" title="2 事务的特性（ACID）"></a>2 事务的特性（ACID）</h2><ul>
<li>A原子性：最小执行单位，要么都成功要么都失败回滚。使用Undo/redo保证，假如某个时刻数据库崩溃了，事务A已经提交，事务B还没有提交。数据库重启时根据redo log将A的数据写到数据文件，根据undo log回滚还未提交的数据。</li>
<li>C一致性：数据符合现实世界的约束。转账之后总和不变，转账后不能出现负值。</li>
<li>I隔离性：并发访问数据库的时候，一个事务不受其他事务影响，各并发事务之间处理数据库是独立的。MVCC与锁</li>
<li>D持久性：事务被提交后，它对数据库的数据的改变是持久的。即使数据库崩溃，也可以使用redo log回滚。</li>
</ul>
<h2 id="3-并发事务存在的问题"><a href="#3-并发事务存在的问题" class="headerlink" title="3 并发事务存在的问题"></a>3 并发事务存在的问题</h2><ul>
<li>脏读：一个事务对数据库的数据进行了修改，还未提交，另一个事务使用了未提交的数据。</li>
<li>丢失修改：举个例子，事务1读到数据A为20，事务2读到数据A为20，事务1执行A = A - 1;事务2执行A = A - 1,实际上A仍然是19，就导致了错误的修改。</li>
<li>不可重复读：一个事务在事务内可能多次读取数据，但是此间可能有其他事务也操作了数据，这时候可能出现事务A多次读取的数据不一致。</li>
<li>幻读：与不可重复读类似，一个事务在事务内多次读取某些数据，但是其他事务插入的一些数据，就是使得事务1发现了一个原本不存在的数据。就是幻读。注意需要是范围。</li>
</ul>
<p><strong>注意</strong>：不可重复度与幻读得区别在于，不可重复读强调的是数据的修改，幻读指的是数据的插入和删除。</p>
<h2 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4 事务隔离级别"></a>4 事务隔离级别</h2><h3 id="4-1-事务并发执行可能遇到的问题"><a href="#4-1-事务并发执行可能遇到的问题" class="headerlink" title="4.1 事务并发执行可能遇到的问题"></a>4.1 事务并发执行可能遇到的问题</h3><ul>
<li>脏写：一个事务修改了另一个事务未提交的数据</li>
<li>脏读：一个事务读到了另一个事务未提交的数据，并且这个数据在另一个事务中还被回滚了</li>
<li>不可重复读：一个事务每次用相同的条件读到另一个事务提交的数据都不同</li>
<li>幻读：一个事务按照某个相同条件多次读取记录时，后者读到了之前没有读到的数据</li>
</ul>
<p>不可重复读的重点是修改，是一个事务多次读取一条记录发现其中某些列的值被修改。而幻读的重点在于一个事务多次使用同样条件进行查询发现记录增多了。</p>
<h3 id="4-2-事务隔离级别"><a href="#4-2-事务隔离级别" class="headerlink" title="4.2 事务隔离级别"></a>4.2 事务隔离级别</h3><ul>
<li>读未提交：可能出现脏读、幻读和不可重复读。</li>
<li>读已提交：可能出现不可重复读和幻读。</li>
<li>可重复读：可能出现幻读。实际上mysql的这个级别可以解决幻读</li>
<li>可串行化：所有事务串行执行</li>
</ul>
<h2 id="6-InnoDb"><a href="#6-InnoDb" class="headerlink" title="6 InnoDb"></a>6 InnoDb</h2><p>innodb页大小为16KB，以页作为磁盘和内存交互的基本单位</p>
<p>Innodb定义了四种行格式：Compact、Redundant、Dynamic、Compressed</p>
<h3 id="6-1-Innodb的数据页格式"><a href="#6-1-Innodb的数据页格式" class="headerlink" title="6.1 Innodb的数据页格式"></a>6.1 Innodb的数据页格式</h3><h4 id="6-1-1-文件头部"><a href="#6-1-1-文件头部" class="headerlink" title="6.1.1.文件头部"></a>6.1.1.文件头部</h4><p>表示页的一些通用信息。</p>
<p>两个比较重要的内容：</p>
<p>一个是和文件尾部一起做的校验和。</p>
<p>第二个是我们直到一些数据往往很大，一页可能无法装载完成，所以其还保存了上一页的地址，以及下一页的地址，为了把分散的页关联起来。</p>
<h4 id="6-1-2-页面头部"><a href="#6-1-2-页面头部" class="headerlink" title="6.1.2.页面头部"></a>6.1.2.页面头部</h4><p>表示数据页的一些专有信息。</p>
<p>比如槽的数量，记录数量，第一个标记为删除的记录地址，因为删除的记录也会通过next_record组成一个单链表以进行重新利用。</p>
<h4 id="6-1-3-最小最大记录"><a href="#6-1-3-最小最大记录" class="headerlink" title="6.1.3.最小最大记录"></a>6.1.3.最小最大记录</h4><p>虚拟的伪记录，分别表示页中的最大和最小记录。</p>
<h4 id="6-1-4-用户记录"><a href="#6-1-4-用户记录" class="headerlink" title="6.1.4.用户记录"></a>6.1.4.用户记录</h4><p>按指定的行格式真实的存储我们插入的记录部分。</p>
<p>一条记录由记录额外信息+真实数据组成。</p>
<p>额外信息中包含记录头信息，记录头信息中有几个的字段。</p>
<p>1.delete_mask：标记记录是否被删除，注意删除了记录之后不会立刻移除掉，而是等待重用。区别就是会让前一条记录的next_record指针指向下一条记录。</p>
<p>2.n_owned：标记当前记录拥有的记录数。每个槽的最后一个记录拥有的记录数就是该槽记录数量。</p>
<p>3.heap_no：在堆中的位置信息，从2开始，因为最大最小占有0和1.</p>
<p>4.next_record：下一条记录<strong>真实数据</strong>的<strong>相对位置</strong></p>
<h4 id="6-1-5-空闲空间"><a href="#6-1-5-空闲空间" class="headerlink" title="6.1.5.空闲空间"></a>6.1.5.空闲空间</h4><p>页中未使用的空闲空间。</p>
<p>最开始的时候实际上没有用户记录，当插入记录的时候，会从空闲空间中申请一个记录大小的空间装载。</p>
<h4 id="6-1-6-页面目录"><a href="#6-1-6-页面目录" class="headerlink" title="6.1.6.页面目录"></a>6.1.6.页面目录</h4><p>记录页中某些记录的相对位置，就是槽在页面中的地址偏移量。</p>
<p>因此查找某个主键就可以分为两步：</p>
<p>1.二分确定该记录所在的槽</p>
<p>2.通过next_record遍历该槽的各个记录</p>
<h4 id="6-1-7-文件尾部"><a href="#6-1-7-文件尾部" class="headerlink" title="6.1.7.文件尾部"></a>6.1.7.文件尾部</h4><p>用于校验页是否完整，主要在内存写入磁盘的过程使用。</p>
<h2 id="7-Innodb记录行格式"><a href="#7-Innodb记录行格式" class="headerlink" title="7 Innodb记录行格式"></a>7 Innodb记录行格式</h2><p><code>InnoDB</code>存储引擎的大叔们到现在为止设计了4种不同类型的<code>行格式</code>，分别是<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>和<code>Compressed</code>行格式。</p>
<h3 id="7-1-Compact-行格式"><a href="#7-1-Compact-行格式" class="headerlink" title="7.1 Compact 行格式"></a>7.1 Compact 行格式</h3><p>主要包括两部分：</p>
<ul>
<li>记录的额外信息</li>
<li>记录的真实数据</li>
</ul>
<h4 id="7-1-1-记录的额外信息"><a href="#7-1-1-记录的额外信息" class="headerlink" title="7.1.1 记录的额外信息"></a>7.1.1 记录的额外信息</h4><p>主要包括三部分：</p>
<ul>
<li>变长字段长度列表：比如有三个列c1 c2 c3都是varchar类型，然后分别内容是’aaaa’ ‘bbb’ ‘c’，那么存储的内容就是16进制的01 03 04，注意是逆序的。2字节</li>
<li>NULL值列表：逆序存储可以为NULL的字段是否是NULL。至少1字节</li>
<li>记录头信息：固定的5个字节，包含记录是否删除</li>
</ul>
<h4 id="7-1-2-记录的真实数据"><a href="#7-1-2-记录的真实数据" class="headerlink" title="7.1.2 记录的真实数据"></a>7.1.2 记录的真实数据</h4><p>除了字段的数据之外，还三个隐藏列：</p>
<ul>
<li>row_id：不是必须的，如果有主键或者存在唯一的索引，那么不需要这个隐藏列。6字节</li>
<li>t_id：事务id。6个字节</li>
<li>roll_pointer：回滚指针，7个字节</li>
</ul>
<p>也就是说至少会有13个字节。</p>
<p>varchar表示的列最多可以占用65535个字节，如果使用ascii字符集，一个字符代表一个字节；如果使用utf-8,那么就是65535/3。</p>
<p>行溢出：132 + 2×(27 + n) &lt; 16384</p>
<h2 id="8-mysql的数据目录与表空间"><a href="#8-mysql的数据目录与表空间" class="headerlink" title="8 mysql的数据目录与表空间"></a>8 mysql的数据目录与表空间</h2><h3 id="8-1-数据文件与索引文件"><a href="#8-1-数据文件与索引文件" class="headerlink" title="8.1 数据文件与索引文件"></a>8.1 数据文件与索引文件</h3><p>数据目录就是我们的数据存放的地方。</p>
<ul>
<li>当创建一个新的数据库的时候，会在<strong>数据目录</strong>下面创建一个和数据库同名的文件夹，并且在该文件夹下面创建一个名为<code>db.opt</code>的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则是个啥。</li>
<li>这个数据库文件夹下面还会有一些文件，包括<strong>表结构的定义文件 表名.frm</strong>，以及<strong>表名.ibd的索引文件</strong>，对于myisam而言因为是非聚簇索引，所以多了一个数据文件所以  表明.myd数据文件</li>
</ul>
<h3 id="8-2-表空间"><a href="#8-2-表空间" class="headerlink" title="8.2 表空间"></a>8.2 表空间</h3><p>思考一个问题，叶子节点是依靠指针连接起来的，那么这会产生多次随机IO吗在范围查询的时候。</p>
<p>实际上innodb对这里进行了优化，将我们的所有页分为了两种类型，一种是由叶子节点组成的数据段，一种是由内部节点组成的段（每一个索引会有两个段）。而段是由区组成的，而一个区包含64个页，一个区就是1M。所以我们在插入数据的时候，在申请磁盘空间的时候，会按区作为单位进行空间的申请，所以如果插入数据不多会造成空间的浪费，但是这在会避免大量的随机IO的产生，也就是一种使用空间换时间的思想。</p>
<p>（实际上这个问题也是做了优化的，如果你只插入很少的数据，那么这个页会从<strong>碎片区</strong>中申请，碎片区是属于表空间的，不属于数据段或者内部段。也就是说，刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的，当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。）</p>
<p>插入数据的过程：首先每一个段会有三个链表，分别是FREE链表、NOT_FULL链表、FULL链表。</p>
<ul>
<li>FREE链表：链表的每一个节点都是一个区（XDES Entry），然后每个区的所有页面都是空闲的。</li>
<li>NOT_FULL链表：区中页面仍有空闲</li>
<li>FULL链表：区中没有空闲的页面</li>
</ul>
<p>所以在插入的时候，先拿到NOT_FULL链表进行分配页面，如果NOT_FULL满了，就从链表中移除并假如FULL链表中，然后从一个FREE链表中拿页面。</p>
<h2 id="8-B-树索引"><a href="#8-B-树索引" class="headerlink" title="8 B+树索引"></a>8 B+树索引</h2><h3 id="8-1-索引原理"><a href="#8-1-索引原理" class="headerlink" title="8.1 索引原理"></a>8.1 索引原理</h3><p>首先，B+树分为两种类型的节点，一种是内部节点、一种是叶子节点。内部节点中存储的是我们的索引列以及指向某一页页号的指针，叶子节点存储的是数据或者主键。那么在查询某一个记录的时候，就是先在内部节点上通过页目录进行二分查找，定位到对应的索引位置，直到查找到叶子节点，在叶子节点中再进行二分查找定位到对应的数据，对于范围查找而言，叶子节点相互之间通过双向指针连接，也方便进行范围查找。也就是说，总的时间复杂度是o(hlogn)。其中h是树的高度，然后n代表的是每个节点包含的数据数量（实际上也不是，因为是按照槽查询的，每个槽可能多个节点）。</p>
<h4 id="8-1-1-为什么用B-树不用其他的数据结构"><a href="#8-1-1-为什么用B-树不用其他的数据结构" class="headerlink" title="8.1.1 为什么用B+树不用其他的数据结构"></a>8.1.1 为什么用B+树不用其他的数据结构</h4><ul>
<li>首先，如果没有索引，那么查找数据只能暴力的顺序查找。第一个点，从事件复杂度的角度上来说是O(n)的，当数据量非常大的时候查询是非常消耗时间的。</li>
<li>其次，如果是hash索引，其时间复杂度可以到O(1)，但是其致命的缺陷在于范围查找，并且也不支持模糊查询。</li>
<li>二叉搜索树在极端情况下会退化为线性链表，尤其是数据库主键自增的情况下。</li>
<li>AVL是一个严格的自平衡二叉树，不会退化为线性链表，但他有两个问题，一是调整二叉树的平衡消耗的性能；还有一个严重的问题是，AVL树每个节点只存储了一个数据，因此一次磁盘IO只取一个节点上的数据是非常不合理的。其次，树形结构的范围查找都是O（n）的。</li>
</ul>
<h4 id="8-1-2-为什么不用B树"><a href="#8-1-2-为什么不用B树" class="headerlink" title="8.1.2 为什么不用B树"></a>8.1.2 为什么不用B树</h4><ul>
<li>B树节点中存储的是数据，B+树内部节点存储的是索引，叶子节点存储的数据。存储的是索引还是数据其实差别是很大的。<ul>
<li>假设3层的B树与B+树。假设每一条记录0.1kb，也就是说，每一页能够存下160条用户记录，对内部节点而言，每一条记录16字节（大概就是一个主键10字节加上一个页号索引6字节），那么大概就是1024条记录。对于B+树而言，三层的树高总共可以存储1024^3次方条记录。对于B树而言，每个节点都存储数据，也就是每个节点都是160条记录，那么三层的树高可以存储160^4 - 1对吧。也就是大概2倍。也就是说相同的记录树而言，b+树的层数要低一些，那么随机IO的次数要少一些。而随机IO通常需要10ms，也就是磁盘的寻道时间+旋转时间+传输时间。</li>
</ul>
</li>
<li>B+树叶子节点用链表连接，方便范围查找。</li>
<li>查询性能稳定</li>
</ul>
<h3 id="8-2-怎么用索引"><a href="#8-2-怎么用索引" class="headerlink" title="8.2 怎么用索引"></a>8.2 怎么用索引</h3><p><strong>如何提高查询效率：</strong></p>
<ul>
<li><p>索引列的类型尽量小，类型越小，每一页存的数据越多，树越低，查的越快</p>
</li>
<li><p>尽量不要使用select * ，否则数据包过大网络传输时间会增加</p>
</li>
<li><p>not in会导致全表扫描</p>
</li>
<li><p>like如何不是最左匹配会导致全表扫描</p>
</li>
<li><p>不要在索引列上做表达式操作，这样会无法使用索引</p>
</li>
<li><p>只为用于搜索，排序，分组的列创建索引</p>
</li>
<li><p>为列的基数大的列创建索引</p>
</li>
<li><p>尽可能的让聚簇索引少的发生页分裂和记录移位操作，建议主键自增如果主键不是严格递增，那么为了保证B+树，那么需要页分裂和记录移位。其次每次插入还要寻找插入位置</p>
</li>
<li><p>对频繁修改的列不要加索引，因为可能出现页分裂</p>
</li>
<li><p>注意不要出现冗余索引和重复索引</p>
</li>
</ul>
<p><strong>count(*) 和 count(1)效率一样。</strong></p>
<p><strong>举一个例子，假如有一个联合索引A B C。</strong></p>
<ul>
<li>全值匹配，where A = a,B = b ,c = C的时候能使用索引。</li>
<li>最左匹配，where A = a,B = b可以；但是where A = a,C = c不行，不满足最左匹配原则。</li>
<li>范围匹配  A = a, B&gt;b1， B&lt;b2 ，C&gt;c ,二分找到A，然后二分找b1,二分找b2。然后在这个范围里面二分找c</li>
<li>ASC、DESC混用是无法进行索引排序的。</li>
</ul>
<h3 id="8-3-B-树索引分类"><a href="#8-3-B-树索引分类" class="headerlink" title="8.3 B+树索引分类"></a>8.3 B+树索引分类</h3><p><strong>聚簇索引</strong>：聚集的意思就是索引文件与数据文件存放在一起，就是叶子节点存放的是用户记录，myisam使用的非聚簇索引叶子节点存放的是数据的地址，需要去数据文件中查找。其次就是需要是主键形成的B+树。</p>
<p><strong>二级索引</strong>（搜索列+页号/主键）：</p>
<p>当搜索条件为其他列的时候，则需要利用二级索引。这个时候需要建立其他的B+树。这个B+树与聚簇索引的区别在于，不再利用主键进行排序，而是利用搜索列进行排序。B+树的叶子节点不再是用户记录。而是主键。之所以不是数据的原因主要是要节省空间。</p>
<p><strong>覆盖索引：</strong></p>
<p>通过一个二级索引查找记录时会产生回表。回表会带来性能损耗，因为我们知道在B+树上索引的过程是通过我们的内部节点去查找对应的叶子节点，而我们使用范围查找时查找出来了范围数据通常存在在相邻的几个数据页中，访问这些数据页往往使用的是顺序IO。而当我们进行回表操作的时候，访问聚簇索引的时候，因为我们通过二级索引查出来的主键可能分散在一些数据页中，因此访问聚簇索引的时候使用的是随机IO。而随机IO需要消耗我们的性能。</p>
<p>而覆盖索引指的是保证我们的查询列表只包含我们的索引列，这就避免了回表的过程。</p>
<p>回表在分页查询中经常出现，举一个例子，假如limit 10 offset 10000，那么实际上如果用的是二级索引，那么会回表10000次，因为Mysql底层用的逻辑算子，limit offset只能作用于引擎层返回的结果，因此它会执行10000次随机IO。逻辑算子主要包含数据源、选择、连接、投影等。</p>
<p>解决方法就是使用覆盖索引，先查出这10个主键，再进行10次查找就可以了。</p>
<p><strong>联合索引</strong>：</p>
<p>以多个列的大小作为排序的规则，在第一列相同的情况下以第二列排序。注意建立联合索引只会额外建立一颗二叉树。</p>
<p><strong>唯一索引</strong>：</p>
<p>唯一索引的属性列不能出现重复的数据，但可以是NULL，一张表可以创建多个唯一索引。创建唯一索引的时候大部分都是为了保证其唯一性而不是索引效率。</p>
<p><strong>全文索引</strong>：</p>
<p>MyIsam和innodb都支持，用于查找文本中的关键字，而不是直接比较是否相等。利用倒排索引（记录关键字到文档的映射）实现。</p>
<h2 id="9-MVCC原理"><a href="#9-MVCC原理" class="headerlink" title="9 MVCC原理"></a>9 MVCC原理</h2><p>首先要知道，Innodb引擎存储的表，它的聚簇索引都包含两个必要的隐藏列，例如<strong>trx_id（事务id）、roll_pointer</strong>：指向undo日志的一个指针，可以通过它来找到该记录修改前的信息。</p>
<p>对于insert undo：只在事务回滚时其作用，事务提交后就被删掉了。<strong>注意，为了支持MVCC删除操作也是打上删除标记，并未真正删除。</strong></p>
<p>当两个事务对一条记录进行Update的时候。首先需要注意，两个事务不能够交叉更新一条记录，也就是说事务1有AB两个更新操作，事务2有CD两个更新操作，那么更新顺序不能是ACBD。因为如果是这样，就是一个事务修改了另一个事务未提交的数据，就是<strong>脏写</strong>，脏写是不允许出现的。（保证脏脏写是通过加锁实现的）</p>
<p>对于update：每条undo日志都是指向前一次更新的undo日志。而当前记录的roll_pointer会指向undo日志。这被称为<strong>版本链</strong>，版本链中包含了<strong>事务id</strong>。事务提交后由于需要支持MVCC，不能被删掉。</p>
<p>在mysql内部，不同的事务隔离级别究竟是如何处理的呢？</p>
<h3 id="9-1-ReadView"><a href="#9-1-ReadView" class="headerlink" title="9.1 ReadView"></a>9.1 ReadView</h3><ul>
<li><p>READ UNCOMMITTED 读未提交</p>
<p>由于读未提交级别可以读到事务未提交的记录，因此直接读取记录就可以了</p>
</li>
<li><p>SERIALIZABLE 串行化</p>
<p>通过加锁的方式来访问记录，当一个事务对一条记录进行增删改查的时候都对其加锁，只有提交后再释放锁。</p>
</li>
<li><p>READ COMMITTED 与 REPEATABLE READ 需要保证读到的是已经提交的数据，所以需要使用到<strong>ReadView</strong></p>
</li>
</ul>
<p><strong>ReadView主要包含四个重要部分，分别是①活跃的事务id列表②最小活跃事务id③下一个事务id④生成该ReadView的事务id</strong></p>
<p><strong>因此，在访问某条记录的时候，通过ReadView就可以判断版本是否可见。</strong></p>
<ol>
<li><strong>根据roll_pointer查找到的版本的事务id等于生成ReadView的事务id，则可以直接访问，意味着事务自身在对其访问，因此可以直接访问。</strong></li>
<li><strong>根据roll_pointer查找到的版本的事务id小于ReadView的最小活跃事务id，表明该版本的事务在当前事务生成ReadView之前就已经提交，所以可以访问。</strong></li>
<li><strong>根据roll_pointer查找到的版本的事务id大于等于ReadView的最大活跃事务id，表明该版本的事务在当前事务生成ReadView之后才开启，所以不可以访问。</strong></li>
<li><strong>根据roll_pointer查找到的版本的事务id在ReadView的最大活跃事务id与最大活跃事务id之间，需要判断该事务id是否在活跃事务id列表中，如果在不可以访问，不在则可以访问</strong></li>
</ol>
<p>而READ COMMITTED 与 REPEATABLE READ的区别就在于创建ReadView的时机不同。</p>
<ul>
<li>READ COMMITTED：在一个事务每次读取数据之前都生成一个ReadView</li>
<li>REPEATABLE READ：在事务第一次读取数据之前生成一个ReadView.</li>
</ul>
<p>总的来说，所谓的多版本并发控制就是在隔离级别为读已提交和可重复读的事务在执行普通的select操作时访问记录的版本链的过程，这样可以使不同事务的读写操作并发执行。<strong>使用MVCC操作的读称为一致性读。</strong></p>
<h2 id="10-锁"><a href="#10-锁" class="headerlink" title="10 锁"></a>10 锁</h2><h3 id="10-1-mysql锁的分类"><a href="#10-1-mysql锁的分类" class="headerlink" title="10.1 mysql锁的分类"></a>10.1 mysql锁的分类</h3><p>mysql锁分为读锁、写锁、表锁、行锁、间隙锁、next-key lock。</p>
<p>在四个隔离级别中加锁是会消耗性能的，读未提交不需要加锁，串行化在读取的时候加上读锁，就不能写，在写入的时候加上写锁，就不能读写。对于读已提交和可重复度而言，他们在读的时候使用MVCC，增删改的时候加锁。</p>
<p><strong>锁定写</strong>：</p>
<ul>
<li>Delete操作：首先在B+树中定位到该记录。然后获取该记录的X锁，再执行delete mask操作。</li>
<li>Update操作：首先在B+树中定位到该记录。然后获取该记录的X锁，然后修改对应字段。</li>
<li>INSERT操作：自带隐式锁。</li>
</ul>
<p>注意：针对记录加锁称为<strong>行锁</strong>，针对表加锁称为<strong>表级锁</strong>。表级锁粒度最大，锁冲突概率高。行锁粒度最小，冲突最小，但是加锁开销大，可能出现死锁。</p>
<p>注意：在对某个表进行增删改查 的时候，Innodb是不会对其添加表级别的S锁或者X锁的。</p>
<p>注意：DDL与DML是互响阻塞的。同一时间，一个表只能执行一类语言。</p>
<table>
<thead>
<tr>
<th>兼容性</th>
<th><code>X</code></th>
<th><code>IX</code>意向独占锁、表锁</th>
<th><code>S</code></th>
<th><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>X</code></td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td><code>IX</code></td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
<tr>
<td><code>S</code></td>
<td>不兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td><code>IS</code></td>
<td>不兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>IS和IX锁只是为了判断当前时间教学楼里有没有被占用的教室用的，也就是在对教学楼加S锁或者X锁时才会用到。</p>
<h3 id="10-2-Innodb中的行级锁"><a href="#10-2-Innodb中的行级锁" class="headerlink" title="10.2 Innodb中的行级锁"></a>10.2 Innodb中的行级锁</h3><ul>
<li><p>Record Lock：通常说的行锁，有S锁共享与X锁排他的区别，for update是排他锁，lock in share mode是共享锁。</p>
</li>
<li><p>Gap 锁：为解决幻读问题，因为事务在读取操作的时候，幻影记录并不存在，无法给这些幻影记录加锁，因此只能加间隙锁。</p>
</li>
<li><p>Next-Key Locks：包含普通行锁和Gap锁的功能</p>
</li>
<li><p>插入意向锁：插入时需要判断是否有gap锁，如果有则需要为其添加一个插入意向锁的锁结构（事务信息、iswaiting、锁类型）</p>
</li>
<li><p><strong>隐式锁</strong>：</p>
<p>但如果一个事务首先<strong>插入</strong>了一条记录，然后如果另一个事务想获取该记录的S锁或者X锁，那么它首先会看该该事务的trx_id是否是活跃事务。如果是的话，会为其创建一个X锁（为其添加一个锁结构，iswaiting 是false），为自己页创建一个锁结构（iswaiting是true）</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>innodb对于行的查询可以使用加锁或者MVCC的方式，加锁加的是next-key locks，可以解决幻读问题。普通的select使用的是MVCC称为快照读，而要使用锁需要加上for update当前读。</p>
</li>
<li><p>以一个例子来说明当前读利用next-key locks解决幻读问题的情况。</p>
<p>假设有（1， 20），（2， 30），（3， 40），（4，50）。其实第一列id为主键。第二列为age为辅助索引。</p>
<p>那么调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where age=40; </span><br></pre></td></tr></table></figure>

<p>后会锁住记录(3,40)本身，以及gap(30,40)和gap(40,50)。如果不锁住，那么事务B可以插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into test values(5,40);</span><br></pre></td></tr></table></figure>

<p>之后再查询就会出现两条记录，这就产生了幻读。</p>
</li>
</ul>
<h3 id="10-3-加锁情况分析"><a href="#10-3-加锁情况分析" class="headerlink" title="10.3 加锁情况分析"></a>10.3 加锁情况分析</h3><p>主要分为聚簇索引、二级索引、然后索引是否命中。</p>
<ul>
<li>聚簇索引，查询命中：只锁住主键索引</li>
<li>聚簇索引，查询未命中：会锁住间隙</li>
<li>二级索引唯一索引，查询命中：锁住索引，并且锁住聚簇索引的主键</li>
<li>二级索引唯一索引，查询未命中：锁住间隙</li>
<li>二级索引非唯一索引，查询命中：锁住索引以及间隙，并且锁住聚簇索引的主键</li>
<li>二级索引非唯一索引，查询未命中：锁住间隙</li>
<li>无索引：所有主键加锁，然后间隙加锁，性能消耗是很大的。</li>
<li>聚簇索引范围查询：假如id&lt;12，那么12-15这一个也会加next-key锁。</li>
<li>二级索引范围查询：二级索引加nextkey锁，和聚簇索引一样。注意主键也会加record lock锁，但是不加gap锁。</li>
</ul>
<h2 id="11SQL"><a href="#11SQL" class="headerlink" title="11SQL"></a>11SQL</h2><h3 id="11-1-sql执行过程"><a href="#11-1-sql执行过程" class="headerlink" title="11.1 sql执行过程"></a>11.1 sql执行过程</h3><p>sql的执行过程最重要的就是<strong>查询优化器的优化</strong>。查询优化器实际上就是根据成本计算的结果来确定我们的执行方法。</p>
<h3 id="11-2-执行方法（访问方法）"><a href="#11-2-执行方法（访问方法）" class="headerlink" title="11.2 执行方法（访问方法）"></a>11.2 执行方法（访问方法）</h3><p>执行方式总的来说分为<strong>全表扫描</strong>以及<strong>基于索引的查询</strong>。</p>
<h4 id="11-2-1-全表扫描"><a href="#11-2-1-全表扫描" class="headerlink" title="11.2.1 全表扫描"></a>11.2.1 全表扫描</h4><p>全表扫描就是先拉取表的所有行，然后在server做一个过滤。</p>
<h4 id="11-2-2-索引查询"><a href="#11-2-2-索引查询" class="headerlink" title="11.2.2 索引查询"></a>11.2.2 索引查询</h4><p>索引查询主要要分为几类：</p>
<ul>
<li>针对主键以及二级唯一索引的等值查询</li>
<li>针对普通二级索引的等值查询</li>
<li>针对索引列的范围查询</li>
<li>直接扫描整个索引</li>
</ul>
<p>对于第一类而言，它的访问方法通常是const（也可能是ref，如果唯一索引 调用 is null语句，因为可能存在多个null值，此时回表可能存在多次随机IO），也就是说explain的type字段是const，因为定位一条记录的速度是最快的。</p>
<p>对于第二类而言，访问方法通常是ref，因为可能等值查询有多个记录，那么比const要慢。</p>
<p>对于第三类，访问方法是range，也会回表。</p>
<p>第四类有一些特别，它的访问方法是index，举一个例子，假如有一个联合索引(a,b,c)，那么select a,b,c from table where b = “str”，这也会使用索引，只是索引的访问方法是index，它的操作流程就是扫描这个联合索引，然后比对条件是否成立即可。<strong>之所以要这样做</strong>，首先是因为二级索引只需要存放所有列以及主键，而聚簇索引除了数据还需要隐藏列，因此二级索引树高会低于聚簇索引因此随机IO会降低。其次，通过覆盖索引，也不需要回表。</p>
<h4 id="11-2-3-判断走哪个索引的小技巧"><a href="#11-2-3-判断走哪个索引的小技巧" class="headerlink" title="11.2.3 判断走哪个索引的小技巧"></a>11.2.3 判断走哪个索引的小技巧</h4><p><strong>一般情况下，只会利用一个二级索引进行查询。查询优化器会对比哪个更好，等值&gt;范围</strong>，当选择好了一个索引后，另一个就会失效，也就是会返回给server层过滤，那么此时，如果是or语句连接，那么就是or true，会导致全表扫描。对于and而言，那么就是and true，就直接删掉这个就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;abc&#x27; AND key2 &gt; 1000;</span><br></pre></td></tr></table></figure>

<p><strong>一些特殊情况下，可能出现使用多个二级索引的情况。</strong>下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure>

<p>如果进行索引的合并的话，从idx_key1二级索引对应的B+树中取出key1 = ‘a’的相关记录。然后从<code>idx_key3</code>二级索引对应的<code>B+</code>树中取出<code>key3 = &#39;b&#39;</code>的相关记录。然后<strong>计算主键交集，最后回表。</strong>如果不进行索引合并，就先按key1回表，然后再过滤。这样的话，回表次数过多，消耗过大。</p>
<p>以下几种情况下，会进行索引合并：</p>
<ul>
<li>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。</li>
<li>主键列可以是范围匹配</li>
</ul>
<p>注意：Union合并用于or，Intersection合并用于and</p>
<h3 id="11-3-查询优化器的优化"><a href="#11-3-查询优化器的优化" class="headerlink" title="11.3 查询优化器的优化"></a>11.3 查询优化器的优化</h3><p>选择走哪个索引，就依赖于查询优化器对每一个索引的成本的计算。成本主要来自于两个方面，一是IO成本、二是CPU成本。IO成本指的是访问一个页面需要的成本，CPU成本指的是访问一条记录需要的成本。</p>
<h4 id="11-3-1-全表扫描的成本计算"><a href="#11-3-1-全表扫描的成本计算" class="headerlink" title="11.3.1 全表扫描的成本计算"></a>11.3.1 全表扫描的成本计算</h4><p>那么对于全表扫描而言，需要知道两个东西，一是聚簇索引占了多少个页面，二是表中有多少记录。这两个数据可以通过show table status查看rows与data_length。用data_length/16kb就是有多少页面，rows就是有多少记录。但是注意，innodb都是估计值，并不准确。</p>
<p>那么IO成本就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页面数*1.0 + 1.1（微调值）</span><br></pre></td></tr></table></figure>

<p>CPU成本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录数*0.2 + 1.0（微调值）</span><br></pre></td></tr></table></figure>

<h4 id="11-3-2-索引的成本计算"><a href="#11-3-2-索引的成本计算" class="headerlink" title="11.3.2 索引的成本计算"></a>11.3.2 索引的成本计算</h4><p>索引的成本计算主要分为<strong>主键索引</strong>、<strong>二级索引</strong>。</p>
<p>对于<strong>二级索引</strong>而言，它的成本主要包含几部分，第一部分是这个索引包括的范围，比如1-10算一个范围，15单个点也算一个范围。每一个范围消耗IO成本1.</p>
<p>第二部分是需要回表的记录数，例如查询是key &gt; a and key &lt; b，那么先定位a这一个记录，再定位b这个记录，然后求出这个范围有多少记录。关于怎么求，实际上有两种方案，如果这两个记录相隔不超过10个页面，那么直接通过扫描统计，否则，沿着a向右读取10个页面，计算每个页面包含多少记录，然后用这个平均值乘以这个ab之间相隔页面数量，这个页面数量通过父节点可以求出来。这样的统计方法称为index dive ，这种方法会造成不精确的后果，也解释了为什么有时候会走错索引。拿到记录数，乘1.0就是IO成本。乘0.2就是CPU成本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 IN (&#x27;aa1&#x27;, &#x27;aa2&#x27;, &#x27;aa3&#x27;, ... , &#x27;zzz&#x27;);</span><br></pre></td></tr></table></figure>

<p>假如范围特别多如上所示，那么通过index dive，就不太合适了。这个时候需要通过统计数据计算成本。利用show index from table可以拿到一个列的基数。那么通过rows/基数得到每个数出现了多少行。就可以计算出回表次数。这种方式的问题也在于不精确，存在走错索引的风险。</p>
<h4 id="11-3-3-连接的成本"><a href="#11-3-3-连接的成本" class="headerlink" title="11.3.3 连接的成本"></a>11.3.3 连接的成本</h4><p>注意：连接的成本在于 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</span><br></pre></td></tr></table></figure>

<p>所以对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：<strong>分别为驱动表和被驱动表选择成本最低的访问方法。</strong></p>
<p>对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：</p>
<ul>
<li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li>
<li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<h3 id="11-4-索引优化"><a href="#11-4-索引优化" class="headerlink" title="11.4 索引优化"></a>11.4 索引优化</h3><h4 id="11-4-1-explain分析"><a href="#11-4-1-explain分析" class="headerlink" title="11.4.1 explain分析"></a>11.4.1 explain分析</h4><p>优化索引第一步就是先分析sql嘛，首先先人为分析一下，做一下成本的计算，然后使用explain查看执行计划，看一下是否符合预期。（在这个时候还需要排除缓存的干扰8.0以下版本，使用select SQL_NO_CACHE去跑sql。）然后说到explain，那么explain里面有实际使用的索引，可能使用的索引（存在走错了索引的情况，假如走A需要100行，走B需要10行，但是B需要回表，因此优化器就选错了选到A了，这里涉及了成本计算的方式），扫描涉及了多少行（不完全统计，大概的数据，这是因为mysql采用的是采样统计，选N个数据页出来，然后计算这些页面扫描的行数，最后取一个平均值再乘涉及的页面），扫描类型是全表扫描还是索引扫描还是range等。如果出现了执行计划与预期不符的情况，则先排除由于统计信息出错导致优化器选择错误，可以使用analyze table tablename来对表进行重新分析。或者使用force index强制走某个索引。select  from table force index(id)。</p>
<p><strong>为何会统计出错：</strong></p>
<p>一般来说，基数统计出来的数据和真实的行数没有很大差距，但是涉及到删除数据新增数据比较频繁的数据表，可能会出现数据表有10万条数据但是基数统计却有20万的情况，这就可能是MVCC在作怪了，因为MySQL的InnoDB的事务支持，需要维持多个数据版本，就有可能某些事务还没结束，还在使用删除了很久的数据导致已删除的数据空间无法释放，而新增的数据又开辟了新的空间，那么这时候就导致基数统计中数据页数量可能出现失误，出现较大误差。</p>
<h4 id="11-4-2-覆盖索引"><a href="#11-4-2-覆盖索引" class="headerlink" title="11.4.2 覆盖索引"></a>11.4.2 覆盖索引</h4><p>除了explain之外，还有就是尽量的避免回表操作，例如你要查a b c三个字段，如果他们包含在联合索引里面，是不需要回表的，这里即时不满足最左匹配，也会走索引，只是索引类型是index。</p>
<p>索引下推：假如有一个联合索引A和B，C。然后查询where a = “a” and b &gt; B and c = ‘c’，理论上无法使用索引，但是实际上会利用索引下推。</p>
<h4 id="11-4-3-普通索引与唯一索引如何选择"><a href="#11-4-3-普通索引与唯一索引如何选择" class="headerlink" title="11.4.3 普通索引与唯一索引如何选择"></a>11.4.3 普通索引与唯一索引如何选择</h4><p>这个问题的核心在于是否能使用到change buffer。我们知道当需要更新一个数据页的时候，如果数据页在内存中，那么可以直接更新。如果不在内存中，则需要先利用随机IO读取这个数据页再更新，而随机IO则是数据库的重量级操作之一。change buffer的作用就是先把数据缓存在change buffer里面，在下一次读入这个页面的时候再把merge过去，这样避免了随机IO。除了访问页面会merge，数据库后台也有线程定期Merge，然后数据库关闭的时候也会merge。因此change buffer可以提升我们的sql执行速率。而对于唯一索引而言，对其的更新操作都需要先判断是否违反了唯一性原则，因此都需要把数据读入到内存，那么就无法使用changge buffer了。需要注意的是，change buffer放在buffer pool中，使用change buffer max size。通常对于写多读少的业务，非常适合。而对于那种更新完马上查询的业务非常不适合。</p>
<h4 id="11-4-4-很长的字段，想做索引，如何优化"><a href="#11-4-4-很长的字段，想做索引，如何优化" class="headerlink" title="11.4.4 很长的字段，想做索引，如何优化"></a>11.4.4 很长的字段，想做索引，如何优化</h4><p>我们知道字段越长，然后B+树每个节点存储的数据越少，树会越高，查询效率会越低。因此，可以尝试建立一个区分度高的前缀索引来实现优化，比如邮箱都是以www开头，就可以先去掉这www（substring）然后建立区分度高的索引，对于身份证，也可以先reverse一下。但前缀索引的话就算是联合索引已经包含了想要的数据，但还是会回表。因为他不知道是否是一个完整的信息。因此，实际上虽然前缀索引占用空间小，但是如果区分度不大甚至会造成多次回表查询操作。但刚才说到了函数，要记住使用了函数就无法走索引了。尽量在java层做这些操作，同时要注意一些隐式的函数调用，比如类型转化，编码格式转换等。</p>
<h3 id="11-5-order-by"><a href="#11-5-order-by" class="headerlink" title="11.5 order by"></a>11.5 order by</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br></pre></td></tr></table></figure>

<p>如上述这条sql，整体的执行流程就是。MySQL 为对应的线程初始化<strong>sort_buffer</strong>，放入需要查询的name、age、city字段；从<strong>索引树idx_city</strong>， 找到第一个满足 city=’深圳’条件的主键 id，拿到这一行数据， 取name、age、city三个字段的值，存到sort_buffer；在 sort_buffer中，将所有数据根据age进行排序；</p>
<p>注意：如果<strong>sort_buffer</strong>放不下，就需要用到临时磁盘文件，使用<strong>外排序。</strong></p>
<p>参数<strong>max_length_for_sort_data</strong>决定了是否使用rowid排序，如果单行大小大于这个值，就会采用rowid排序，从而避免外排序。rowid排序的劣势在于多了一次回表的操作。</p>
<h5 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h5><ol>
<li>利用联合索引，将无序变为有序，避免排序操作。</li>
<li>利用覆盖索引，避免回表操作</li>
<li>MySQL服务器配置的话，可以调整max_length_for_sort_data参数，使得不走rowid排序。</li>
</ol>
<p>注意：如何order by的字段有索引但是没有用where，那么会全表扫描（因为索引回表操作）；其次，如果加了limit那么可能会走索引。</p>
<h3 id="11-6-分页limit过大时，会导致大量排序怎么办"><a href="#11-6-分页limit过大时，会导致大量排序怎么办" class="headerlink" title="11.6 分页limit过大时，会导致大量排序怎么办?"></a>11.6 分页limit过大时，会导致大量排序怎么办?</h3><p>假设SQL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A order by a limit 100000,10</span><br></pre></td></tr></table></figure>

<ul>
<li>可以记录上一页最后的id，下一页查询时，查询条件带上id，如： where id &gt; 上一页最后id limit 10。</li>
<li>使用覆盖索引，先查出这10个主键，再进行10次查找就可以了。这样避免了回表操作</li>
</ul>
<h2 id="12-日志"><a href="#12-日志" class="headerlink" title="12 日志"></a>12 日志</h2><h3 id="12-1-redo-log（Innodb独有）"><a href="#12-1-redo-log（Innodb独有）" class="headerlink" title="12.1 redo log（Innodb独有）"></a>12.1 redo log（Innodb独有）</h3><p>如果没有redo log，每次事务提交之后都把所有修改的页面刷新到磁盘，那么会有两个问题，第一个问题是刷新一个完整的数据页太浪费了，因为你可能只修改了这一个数据页16kb的某几个字节；第二个问题是随机IO速度慢，这是因为一个事务可能涉及了不同的页面的修改，而这可能存在多次随机IO。</p>
<p>redo log每一个记录存储的内容是：将第几个表空间的第几个页的某一个偏移量上多少个字节改为某一个数。这也就是解决了这两个问题，一是只需要记录修改了的部分、二是redo log日志是顺序写入了，避免了随机IO。</p>
<h4 id="12-1-1-文件格式"><a href="#12-1-1-文件格式" class="headerlink" title="12.1.1 文件格式"></a>12.1.1 文件格式</h4><p>logfile中三个指针比较重要：</p>
<ul>
<li>checkPoint_lsn指针：表示当前数据脏页已经写入磁盘的部分，这部分logfile是可以覆盖的。这个值实际上就是flush链表上的第一个值的lsn值。</li>
<li>flush_to_disk_lsn指针：表示数据脏页还没有刷新到磁盘，但是对应的redo log已经写入磁盘了</li>
<li>lsn指针：表示redo 日志还在redo log buffer中，还没有刷新到磁盘</li>
</ul>
<h4 id="12-1-2-崩溃恢复"><a href="#12-1-2-崩溃恢复" class="headerlink" title="12.1.2 崩溃恢复"></a>12.1.2 崩溃恢复</h4><p>第一步要确定<strong>恢复起点</strong>。这与logfile中的三个指针有关，在checkPoint_lsn之后的表示都没有写入脏页到磁盘的数据，因此，起点就是checkPoint_lsn。第二步要确定<strong>恢复终点</strong>，logfile是由block组成的，每一个block512个字节，当遇到某一个block中数据没有达到512字节，也就是意味着到了终点。<strong>第三步</strong>就从起点开始扫描到终点，按照redo日志的内容开始恢复。这一步可以使用hash表进行加速，因为redo日志是由表空间、页号组成，那么将表空间和页号作为hash的key，然后相同的表空间和页号的数据用拉链串起来，这样一次性恢复一个表空间的页面的所有数据，可以避免随机IO。</p>
<h4 id="12-1-3-刷盘时机"><a href="#12-1-3-刷盘时机" class="headerlink" title="12.1.3 刷盘时机"></a>12.1.3 刷盘时机</h4><p>参数innodb_flush_log_at_trx_commit的值：</p>
<ul>
<li>0：表示在事务提交时不立即向磁盘中同步<code>redo</code>日志，这个任务是交给后台线程做的。<strong>存在丢失数据的风险</strong></li>
<li>1：在事务提交时需要将<code>redo</code>日志同步到磁盘，可以保证事务的<code>持久性</code>。<strong>默认值</strong></li>
<li>2：事务提交时需要将<code>redo</code>日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。这种情况下如果数据库挂了，操作系统没挂的话，事务的<code>持久性</code>还是可以保证的，但是操作系统也挂了的话，那就不能保证<code>持久性</code>了。</li>
</ul>
<h4 id="12-1-4-redo-log与binlog区别"><a href="#12-1-4-redo-log与binlog区别" class="headerlink" title="12.1.4 redo log与binlog区别"></a>12.1.4 redo log与binlog区别</h4><p>由binlog和redo log的区别可知：binlog日志只用于归档，只依靠binlog是没有crash-safe能力的。但只有redo log也不行，因为redo log是InnoDB特有的，且日志上的记录落盘后会被覆盖掉。因此需要binlog和redo log二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p>
<p>如果整个数据库的数据都被删除了，<code>binlog</code>存储着所有的数据变更情况，那么可以通过<code>binlog</code>来对数据进行恢复。但不能使用redolog，因为redolog的数据是会被覆盖掉的。</p>
<h4 id="12-1-5-redo-log-amp-binlog两阶段提交"><a href="#12-1-5-redo-log-amp-binlog两阶段提交" class="headerlink" title="12.1.5 redo log &amp; binlog两阶段提交"></a>12.1.5 redo log &amp; binlog两阶段提交</h4><p>MySQL需要保证<code>redo log</code>和<code>binlog</code>的<strong>数据是一致</strong>的</p>
<ul>
<li>如果<code>redo log</code>写失败了，而<code>binlog</code>写成功了。那假设内存的数据还没来得及落磁盘，机器就挂掉了。那主从服务器的数据就不一致了。</li>
<li>如果<code>redo log</code>写成功了，而<code>binlog</code>写失败了。那从服务器就拿不到最新的数据了。</li>
</ul>
<p>两阶段提交过程：</p>
<ul>
<li>阶段1：InnoDB<code>redo log</code> 写盘，InnoDB 事务进入 <code>prepare</code> 状态</li>
<li>阶段2：<code>binlog</code> 写盘，InooDB 事务进入 <code>commit</code> 状态</li>
<li>每个事务<code>binlog</code>的末尾，会记录一个 <code>XID event</code>，标志着事务是否提交成功，也就是说，恢复过程中，<code>binlog</code> 最后一个 XID event 之后的内容都应该被 purge。</li>
</ul>
<h3 id="12-2-undo-log"><a href="#12-2-undo-log" class="headerlink" title="12.2 undo log"></a>12.2 <strong>undo log</strong></h3><p><code>undo log</code>主要有两个作用：回滚和多版本控制(MVCC)</p>
<p>数据库事务四大特性中有一个是原子性，具体来说就是 原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。</p>
<p>实际上，原子性底层就是通过undo log实现的。undo log主要记录了数据的逻辑变化，比如一条INSERT语句，对应一条DELETE的undo log，对于每个UPDATE语句，对应一条相反的UPDATE的undo log，这样在发生错误时，就能回滚到事务之前的数据状态。</p>
<p>同时，undo log也是MVCC(多版本并发控制)实现的关键。</p>
<h3 id="12-3-binlog（什么引擎都有）"><a href="#12-3-binlog（什么引擎都有）" class="headerlink" title="12.3 binlog（什么引擎都有）"></a>12.3 binlog（什么引擎都有）</h3><p>binlog记录的是数据库的<strong>写入</strong>操作，是一种逻辑日志（sql语句和事务id），其是以追加的方式写入到binlog日志的。binlog主要用于主从复制以及数据恢复，主从复制的时候在master端开启binlog，然后将binlog发送到各个slave端，slave端重放binlog从而实现主从数据一致。数据恢复的时候可以使用mysqlbinlog工具恢复数据。</p>
<p><strong>刷盘时机：</strong></p>
<ul>
<li>0：不去强制要求，由系统自行判断何时写入磁盘；</li>
<li>1：每次commit的时候都要将binlog写入磁盘；通常是1</li>
<li>N：每N个事务，才会将binlog写入磁盘。</li>
</ul>
<p>binlog日志有三种格式，分别为STATMENT、ROW和MIXED。</p>
<p><strong>STATMENT</strong></p>
<p>基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。</p>
<ul>
<li>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 从而提高了性能；</li>
<li>缺点：在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等。</li>
</ul>
<p><strong>ROW</strong></p>
<p>基于行的复制(row-based replication, RBR)，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了。</p>
<ul>
<li>优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题；</li>
<li>缺点：会产生大量的日志，尤其是alter table的时候会让日志暴涨</li>
</ul>
<p><strong>MIXED</strong></p>
<p>基于STATMENT和ROW两种模式的混合复制(mixed-based replication, MBR)，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog。</p>
<h2 id="11-数据库大表优化"><a href="#11-数据库大表优化" class="headerlink" title="11 数据库大表优化"></a>11 数据库大表优化</h2><p>第一优化你的sql和索引；</p>
<p>第二加缓存，memcached,redis；</p>
<p>第三以上都做了后，还是慢，就做主从复制或主主复制，读写分离，可以在应用层做，效率高，也可以用三方工具，第三方工具推荐360的atlas,其它的要么效率不高，要么没人维护；</p>
<p>第四如果以上都做了还是慢，不要想着去做切分</p>
<ol>
<li>限定数据的范围</li>
<li>读写分离：主库写、从库读。</li>
<li>垂直分区</li>
<li>水平分区</li>
</ol>
<p>表记录在千万级以下不需要考虑拆分。</p>
<h3 id="11-1-字段"><a href="#11-1-字段" class="headerlink" title="11.1 字段"></a>11.1 字段</h3><p>只赋予需要使用的存储空间。例如整形只赋予tinyint，varchar给定大小等。</p>
<h3 id="11-2-索引"><a href="#11-2-索引" class="headerlink" title="11.2 索引"></a>11.2 索引</h3><ul>
<li><p>索引并非越多越好。查询、分组、排序的列上用索引。</p>
</li>
<li><p>避免where使用NULL值判断，否则导致全表扫描。</p>
</li>
<li><p>选取基数大的列作为索引。</p>
</li>
<li><p>字符字段最好别作主键，且只建立前缀索引。</p>
</li>
<li><p>不使用外键，由应用层程序来保证。外键在更新时会触发级联更新，增加了复杂性。也增加了额外维护外键的工作。但实际上外键也保证了数据库数据的一致性和完整性。</p>
</li>
</ul>
<h3 id="11-3-查询SQL"><a href="#11-3-查询SQL" class="headerlink" title="11.3 查询SQL"></a>11.3 查询SQL</h3><ul>
<li>查询时不做列运算，因为列运算会导致全表扫描，尽可能将操作移到右边。SELECT id WHERE age = 10/2</li>
<li>不使用select *</li>
<li>模糊查询匹配前缀而非后缀</li>
</ul>
<h2 id="12-数据库池化思想，什么是数据库连接池？为什么需要数据库连接池"><a href="#12-数据库池化思想，什么是数据库连接池？为什么需要数据库连接池" class="headerlink" title="12 数据库池化思想，什么是数据库连接池？为什么需要数据库连接池"></a>12 数据库池化思想，什么是数据库连接池？为什么需要数据库连接池</h2><p>常见的java线程池也是池化设计。这类设计通过初始预设资源解决每次获取资源的消耗。</p>
<p>数据库连接的本质就是一个socket连接。数据库连接池就是维护这些socket连接的缓存，在连接池中，创建连接后，将其放置在池中，并再次使用它。如果所有连接都被使用，又有新的连接请求，那么会创建一个新连接并添加到池中。</p>
<h2 id="13-分库分表后主键id如何处理"><a href="#13-分库分表后主键id如何处理" class="headerlink" title="13 分库分表后主键id如何处理"></a>13 分库分表后主键id如何处理</h2><p>利用全局id来支持。</p>
<p>全局id的生成方式有：</p>
<ul>
<li>UUID：不适合主键，第一是字符串，并且太长且无序。因此查询效率非常低</li>
<li>数据库自增id：利用一个单库专门作id，每次都先从数据库中取，然后加一。</li>
<li>利用redis生成id</li>
<li>获取系统当前时间：并发很高的时候会重复</li>
<li><strong>snowflake算法：分布式id生成算法：</strong></li>
</ul>
<h2 id="15-数据库存储时间"><a href="#15-数据库存储时间" class="headerlink" title="15 数据库存储时间"></a>15 数据库存储时间</h2><p>首先，不要使用字符串存储，因为字符串占用空间大，比较效率低。</p>
<p>其次，在DataTime和TimeStamp中选择TimeStamp，因为DataTime与时区无关，在世界任何角落取出对应数据都是当当前设置的时间。而TimeStamp在不同时区查出来的值会作对应的换算。</p>
<p>另外，也存在着使用时间戳（1970至今的秒数），这种方式在作比较的时候会快一些。但其表示不够明显。</p>
<h2 id="16-如何实现MYSQL的读写分离han"><a href="#16-如何实现MYSQL的读写分离han" class="headerlink" title="16  如何实现MYSQL的读写分离han"></a>16  如何实现MYSQL的读写分离han</h2><ul>
<li>基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</li>
</ul>
<h3 id="16-1-主从复制原理"><a href="#16-1-主从复制原理" class="headerlink" title="16.1 主从复制原理"></a>16.1 主从复制原理</h3><ul>
<li>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</li>
<li>这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是<strong>有延时</strong>的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</li>
<li>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</li>
</ul>
<p><strong>解决方案：</strong>一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p>
<ul>
<li>半同步复制：指的就是主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成了。</li>
<li>并行复制：指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是库级别的并行。</li>
</ul>
<h3 id="16-2-主从同步延时问题"><a href="#16-2-主从同步延时问题" class="headerlink" title="16.2 主从同步延时问题"></a>16.2 主从同步延时问题</h3><p>是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。我们通过 MySQL 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status</span><br></pre></td></tr></table></figure>

<p>查看 <code>Seconds_Behind_Master</code> ，可以看到从库复制主库的数据落后了几 ms。</p>
<p>一般来说，如果主从延迟较为严重，有以下解决方案：</p>
<ul>
<li>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</li>
<li>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。</li>
<li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li>
<li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</li>
</ul>
<p><strong>注意：从服务器可以使用MyIsam。</strong></p>
<h2 id="17-分库分表了解吗？如果进行垂直拆分和水平拆分"><a href="#17-分库分表了解吗？如果进行垂直拆分和水平拆分" class="headerlink" title="17 分库分表了解吗？如果进行垂直拆分和水平拆分"></a>17 分库分表了解吗？如果进行垂直拆分和水平拆分</h2><h3 id="17-1-什么是分库分表"><a href="#17-1-什么是分库分表" class="headerlink" title="17.1 什么是分库分表"></a>17.1 什么是分库分表</h3><ul>
<li>分库：从单个数据库拆分成多个数据库的过程，将数据散落在多个数据库中。</li>
<li>分表：从单张表拆分成多张表的过程，将数据散落在多张表内。</li>
</ul>
<h3 id="17-2-为什么要分库分表"><a href="#17-2-为什么要分库分表" class="headerlink" title="17.2 为什么要分库分表"></a>17.2 为什么要分库分表</h3><p>分库分表主要考虑两个问题，一是数据库中记录过多，导致SQL操作过慢。二是高峰期并发量过大。就是<strong>提高性能</strong>、<strong>增加可用性</strong></p>
<ul>
<li>比如，如果查询QPS为3500，假设单库可以支撑1000个连接数的话，那么就可以考虑拆分成4个库，来分散查询连接压力。</li>
<li>如果单表数据量过大，当数据量超过一定量级后，无论是对于数据查询还是数据更新，在经过索引优化等纯数据库层面的传统优化手段之后，还是可能存在性能问题。这时候就要分表</li>
</ul>
<h3 id="17-3-分库还是分表"><a href="#17-3-分库还是分表" class="headerlink" title="17.3 分库还是分表"></a>17.3 分库还是分表</h3><table>
<thead>
<tr>
<th>切分方案</th>
<th>解决的问题</th>
</tr>
</thead>
<tbody><tr>
<td>只分库不分表</td>
<td>数据库读/写QPS过高，数据库连接数不足</td>
</tr>
<tr>
<td>只分表不分库</td>
<td>单表数据量过大，存储性能遇到瓶颈</td>
</tr>
<tr>
<td>分库加分表</td>
<td>连接数不足+数据量过大</td>
</tr>
</tbody></table>
<h3 id="17-4-分多少个表"><a href="#17-4-分多少个表" class="headerlink" title="17.4 分多少个表"></a>17.4 分多少个表</h3><p>通常认为一张表500w条数据就需要分了。那么系统很大，一天要产生10w条记录，那么以5年为年限来计算的话，就大概会产生1亿多的数据。那么以500w分分割的话，大概需要接近30张表，那么就可以分割成32张表。</p>
<h3 id="17-5-分多少个库"><a href="#17-5-分多少个库" class="headerlink" title="17.5 分多少个库"></a>17.5 分多少个库</h3><p>可以根据历史QPS等数据评估，假设我们只需要3500数据库连接数，如果单库可以承担最高1000个数据库连接，那么我们就可以拆分成4个库。</p>
<h3 id="17-6-如何切分"><a href="#17-6-如何切分" class="headerlink" title="17.6 如何切分"></a>17.6 如何切分</h3><p>首先对字段特别多的表做一个垂直拆分，把一个大表拆成一些独立的小表，然后通过字段关联，或者说如果一张表有10个字段，其中只有3个字段需要频繁修改，那么就可以考虑把这3个字段拆分到子表。避免在修改这3个数据时，影响到其余7个字段的查询行锁定。</p>
<p>垂直拆分之后，可能数据库连接数仍然不足。这个时候就需要进行水平拆分，通常可以用hash取模，一致性hash，或者直接是一段连续的数据，或者看用户是不是会员等。</p>
<p>拆分之后，<strong>中间件可以根据你指定的某个字段值</strong>，比如说 userid，<strong>自动路由到对应的库上去，然后再自动路由到对应的表里去</strong>。</p>
<table>
<thead>
<tr>
<th>orderId</th>
<th>id % 32 (库)</th>
<th>id / 32 % 32 (表)</th>
</tr>
</thead>
<tbody><tr>
<td>259</td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>1189</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>352</td>
<td>0</td>
<td>11</td>
</tr>
<tr>
<td>4593</td>
<td>17</td>
<td>15</td>
</tr>
</tbody></table>
<h4 id="17-6-1-水平切分"><a href="#17-6-1-水平切分" class="headerlink" title="17.6.1 水平切分"></a>17.6.1 水平切分</h4><p>①利用hash取模②利用id范围或者时间范围</p>
<p>还可以按照用户是不是会员进行拆分</p>
<h4 id="17-6-2-垂直拆分"><a href="#17-6-2-垂直拆分" class="headerlink" title="17.6.2 垂直拆分"></a>17.6.2 垂直拆分</h4><p>垂直切分可以简单理解为，把一张表的不同字段拆分到不同的表中。</p>
<p>比如：假设有个小型电商业务，把一个订单相关的商品信息、买卖家信息、支付信息都放在一张大表里。可以考虑通过垂直切分的方式，把商品信息、买家信息、卖家信息、支付信息都单独拆分成独立的表，并通过订单号跟订单基本信息关联起来。</p>
<p>也有一种情况，如果一张表有10个字段，其中只有3个字段需要频繁修改，那么就可以考虑把这3个字段拆分到子表。避免在修改这3个数据时，影响到其余7个字段的查询行锁定。</p>
<h3 id="17-7-ID的生成问题"><a href="#17-7-ID的生成问题" class="headerlink" title="17.7 ID的生成问题"></a>17.7 ID的生成问题</h3><h4 id="17-7-1-UUID"><a href="#17-7-1-UUID" class="headerlink" title="17.7.1 UUID"></a>17.7.1 UUID</h4><p>UUID可以得到一个唯一的标识。</p>
<p>优点在于生成简单，没有网络消耗。</p>
<p>缺点在于是一个无序的字符串，不具备自增的特性。因此在使用Mysql的时候性能消耗较大。</p>
<h4 id="17-7-2-数据库自增ID"><a href="#17-7-2-数据库自增ID" class="headerlink" title="17.7.2 数据库自增ID"></a>17.7.2 数据库自增ID</h4><p>使用一个单独的表来生成ID，每次需要一个ID的时候往表中插入一条数据，返回一个主键ID。</p>
<p>但是DB存在宕机风险，而且无法抗住高并发场景。</p>
<p>因此，可以换成集群来实现。假如两个实例，一个实例就从初始值1开始步长设置为2.第二个实例就从初始值2开始步长为2.就不会出现重复ID。但需要多少个实例，最开始不好确定。</p>
<h4 id="17-7-3-基于数据库的号段模式"><a href="#17-7-3-基于数据库的号段模式" class="headerlink" title="17.7.3 基于数据库的号段模式"></a>17.7.3 基于数据库的号段模式</h4><p>从数据库批量的获取自增ID，每次获取一个范围，例如1-1000.</p>
<p>用完之后再申请新的号段，对max_id做一次update操作，使最大可用id maxid = maxid + step。并借助version乐观锁的方式更新。</p>
<h4 id="17-7-4-基于redis"><a href="#17-7-4-基于redis" class="headerlink" title="17.7.4 基于redis"></a>17.7.4 基于redis</h4><p>利1用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。</p>
<p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p>
<ul>
<li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>
<li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li>
</ul>
<h4 id="17-7-5-雪花算法"><a href="#17-7-5-雪花算法" class="headerlink" title="17.7.5 雪花算法"></a>17.7.5 雪花算法</h4><p><strong>第一位</strong> 占用1bit，其值始终是0，没有实际作用。 <strong>2.时间戳</strong> 占用41bit，精确到毫秒，总共可以容纳约69年的时间。 <strong>3.工作机器id</strong> 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。 <strong>4.序列号</strong> 占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.uestc.jacob.course.util;<span class="comment">/** * 用于生成分布式id * 1 + 41 + 5 + 5 + 12 */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowflakeUtil</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> START_TIMESTAMP = <span class="number">1480166465631L</span>;<span class="comment">//起始的时间戳    /**     * 每部分所占用的位数     */    private final static long SEQUENCE_BIT = 12;//序列号占用的位数    private final static long MACHINE_BIT = 5;//机器标识占用的位数    private final static long DATA_CENTER_BIT = 5;//数据中心占用的位数    /**     * 每部分的最大值     */    private final static long MAX_SEQUENCE = -1 ^ (-1L &lt;&lt; SEQUENCE_BIT);//后12位为1    private final static long MAX_MACHINE_NUM = -1 ^ (-1L &lt;&lt; MACHINE_BIT);    private final static long MAX_DATA_CENTER_NUM = -1 ^ (-1L &lt;&lt; DATA_CENTER_BIT);    /**     * 每部分向左的位移位数     *     * @param args     */    private final static long MACHINE_LEFT = SEQUENCE_BIT;    private final static long DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;    private final static long TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;    private long dataCenterId;//数据中心    private long machineId;//机器标识    private long sequence = 0L;//序列号    private long lastTimeStamp = -1L;//上一次时间戳    private long getNextMill() &#123;        long mill = getNewTimeStamp();        while (mill &lt;= lastTimeStamp) &#123;            mill = getNewTimeStamp();        &#125;        return mill;    &#125;    private long getNewTimeStamp() &#123;        return System.currentTimeMillis();    &#125;    /**     * 根据指定的数据中心id和机器表示id生成指定的序列号     */    public SnowflakeUtil(long dataCenterId, long machineId) &#123;        if (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; 0) &#123;            throw new IllegalArgumentException(&quot;DtaCenterId can&#x27;t be greater than MAX_DATA_CENTER_NUM or less than 0！&quot;);        &#125;        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123;            throw new IllegalArgumentException(&quot;MachineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0！&quot;);        &#125;        this.dataCenterId = dataCenterId;        this.machineId = machineId;    &#125;    /**     * 产生下一个id     */    public synchronized long nextId() &#123;        long currTimeStamp = getNewTimeStamp();        if (currTimeStamp &lt; lastTimeStamp) &#123;            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);        &#125;        if (currTimeStamp == lastTimeStamp) &#123;            //毫秒相同，那么序列号自增            sequence = (sequence + 1) &amp; MAX_SEQUENCE;            if (sequence == 0L) &#123;                currTimeStamp = getNextMill();            &#125;        &#125; else &#123;            sequence = 0L;        &#125;        lastTimeStamp = currTimeStamp;        return (currTimeStamp - lastTimeStamp) &lt;&lt; TIMESTAMP_LEFT                | dataCenterId &lt;&lt; DATA_CENTER_LEFT                | machineId &lt;&lt; MACHINE_LEFT                | sequence;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="17-1-如何动态切换分库分表"><a href="#17-1-如何动态切换分库分表" class="headerlink" title="17.1 如何动态切换分库分表"></a>17.1 如何动态切换分库分表</h3><ul>
<li>停机迁移：挂一个维护信息，然后把数据库的数据进行迁移，然后修改一些SQL啊数据库配置等。</li>
<li>双写迁移方案：写库的时候，除了对老库进行写入，同时也对新库进行写入。然后读老库的数据写入新库，不过要注意不要覆盖新库的写入。写完后要作新老库数据对比，不一致的从老库中再读入。</li>
</ul>
<p>mysql单表容量1千万以下是最佳状态，此时树高3-5.</p>
<h2 id="18-三级封锁协议"><a href="#18-三级封锁协议" class="headerlink" title="18 三级封锁协议"></a>18 三级封锁协议</h2><ul>
<li>一级封锁协议：事务T1要修改A记录时要加X锁。直到T1结束才释放。此时不要求读数据加锁，只能保证不出现脏写。</li>
<li>二级封锁协议：事务T1要修改A记录时要加X锁。直到T1结束才释放。此时要求读数据加S锁（但读取完毕马上释放，因此事务T1如可以再次获取X锁），能保证不出现脏读。</li>
<li>三级封锁协议：事务T1要修改A记录时要加X锁。直到T1结束才释放。此时要求读数据加S锁（直到结束才释放），能保证不出现不可重复读。</li>
</ul>
<h2 id="19-数据库范式"><a href="#19-数据库范式" class="headerlink" title="19 数据库范式"></a>19 数据库范式</h2><ul>
<li>第一范式：属性不可分</li>
<li>第二范式：每个非主属性完全依赖于键码，利用分解来保证。</li>
<li>第三范式：非主属性不传递函数依赖于键码</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Jacob</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2021/10/03/mysql/">http://example.com/2021/10/03/mysql/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Jacob</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2021/10/03/mysql/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="mysql">
                        
                        <span class="card-title">mysql</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-10-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Jacob
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2021/10/03/mysql/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="mysql">
                        
                        <span class="card-title">mysql</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-10-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Jacob
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Jacob</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:zhou.jiahao@foxmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1078463794" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1078463794" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
